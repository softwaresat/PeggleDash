#include "Ball.h"
#include "GameObject.h"
#include <cstdint>
#include <iostream>
#include <cmath> // For more complex physics if needed, maybe not for simple reflect


const int32_t angleTable[21][4] = {
  {     0,  0,  128, -221 },
  {  1536,  0,  150, -207 },
  {  3072,  0,  171, -190 },
  {  4864,  0,  190, -171 },
  {  6400,  0,  207, -150 },
  {  7936,  0,  221, -127 },
  {  9728,  0,  233, -104 },
  { 11264,  0,  243,  -79 },
  { 12800,  0,  250,  -53 },
  { 14592,  0,  254,  -26 },
  { 16128,  0,  256,    0 },
  { 17664,  0,  254,   26 },
  { 19456,  0,  250,   53 },
  { 20992,  0,  243,   79 },
  { 22528,  0,  233,  104 },
  { 24320,  0,  221,  127 },
  { 25856,  0,  207,  150 },
  { 27392,  0,  190,  171 },
  { 29184,  0,  171,  190 },
  { 30720,  0,  150,  207 },
  { 32512,  0,  128,  221 },
};

const uint16_t BallSprite[] = {
 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x07ED, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 0x0000, 0x0000, 0x0000, 0x0000, 0xFB80, 0xF640, 0xE7E0, 0x97E0, 0x3FE0, 0x07E2, 0x1346, 0x0000, 0x079F, 0x0000, 0x0000, 0x0000,
 0x0000, 0x0000, 0x0000, 0xF900, 0xFB80, 0xF640, 0xE7E0, 0x97E0, 0x3FE0, 0x07E2, 0x07ED, 0x07F6, 0x0000, 0x053F, 0x0000, 0x0000,
 0x0000, 0x0000, 0xF805, 0xF900, 0xFB80, 0x0000, 0xE7E0, 0x97E0, 0x3FE0, 0x0000, 0x07ED, 0x07F6, 0x079F, 0x053F, 0x0000, 0x0000,
 0x0000, 0xF80F, 0xF805, 0xF900, 0xFB80, 0xF640, 0xE7E0, 0x97E0, 0x3FE0, 0x07E2, 0x0000, 0x07F6, 0x079F, 0x0000, 0x029F, 0x0000,
 0x0000, 0xF80F, 0xF805, 0x0000, 0xFB80, 0xF640, 0x0000, 0x0000, 0x0000, 0x07E2, 0x07ED, 0x0000, 0x079F, 0x053F, 0x029F, 0x0000,
 0x0000, 0xF80F, 0xF805, 0xF900, 0xFB80, 0x0000, 0xE7E0, 0x97E0, 0x3FE0, 0x07E2, 0x07ED, 0x0000, 0x079F, 0x053F, 0x029F, 0x0000,
 0x0000, 0xF80F, 0x0000, 0xF900, 0xFB80, 0x0000, 0xE7E0, 0x0000, 0x3FE0, 0x07E2, 0x07ED, 0x0000, 0x079F, 0x053F, 0x029F, 0x0000,
 0x0000, 0xF80F, 0xF805, 0xF900, 0xFB80, 0x0000, 0xE7E0, 0x97E0, 0x3FE0, 0x07E2, 0x07ED, 0x1795, 0x079F, 0x0021, 0x029F, 0x0000,
 0x0000, 0xF80F, 0xF805, 0xF920, 0xFB80, 0xF640, 0xE7E0, 0x97E0, 0x3FE0, 0x07E2, 0x0000, 0x07F6, 0x079F, 0x0000, 0x029F, 0x0000,
 0x0000, 0xD8EF, 0xF805, 0x0000, 0xFB80, 0xF640, 0xE7E0, 0x0000, 0x0000, 0x2645, 0x07ED, 0x07F6, 0x0000, 0x053F, 0x0000, 0x0000,
 0x0000, 0x0000, 0xF805, 0xF900, 0x0000, 0xF640, 0xE7E0, 0x97E0, 0x3FE0, 0x07E2, 0x07ED, 0x0020, 0x079F, 0x053F, 0x0000, 0x0000,
 0x0000, 0x0000, 0x0000, 0xF900, 0xFB80, 0x0000, 0x0000, 0x97E0, 0x3FE0, 0x0000, 0x0000, 0x07F6, 0x079F, 0x0000, 0x0000, 0x0000,
 0x0000, 0x0000, 0x0000, 0x0000, 0xDB83, 0xF640, 0xE7E0, 0x97E0, 0x3FE0, 0x07E2, 0x07ED, 0x0123, 0x0000, 0x0000, 0x0000, 0x0000,
 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

};


uint16_t tableLength = 201;

Ball::Ball(int32_t angle) 
{
    int index = (angle * (20))/2000;
    active = false;
    x = angleTable[index][0];
    y = angleTable[index][1];
    vx = angleTable[index][2];
    vy = angleTable[index][3];
    image = BallSprite;
    h = 16;
    w = 16;
}

void Ball::moveBall(){


    x += vx;
    y -= vy;

    if(x/256 >= 128 || x <= 0){
        vx = -vx;
    }
    if(y/256 >= 160 || y <= 0){
        vy = -vy;
    }
}

void Ball::reset(int32_t angle){
    int index = (angle * (20))/2000;
    active = false;
    x = angleTable[index][0];
    y = angleTable[index][1];
    vx = angleTable[index][2];
    vy = angleTable[index][3];    
}

void Ball::simpleReflect() {
    // Very basic reflection: just reverse both velocity components.
    // This isn't physically accurate for angled collisions but is simple.
    // A better approach would determine the collision normal.
    vx = -vx;
    vy = -vy;

    // Optional: Add a small push away from the collision point to prevent sticking
    // This requires knowing the relative position of the ball and peg.
    // Example: move ball one step back along the reversed velocity vector
    // x += vx / 16; // Adjust divisor for desired push strength
    // y += vy / 16;
}

bool Ball::getActive(){
    return active;
}

void Ball::setActive(){
    active = true;
}

int32_t Ball::getX(){
    return x;
}

int32_t Ball::getY(){
    return y;
}

int16_t Ball::getW(){
    return w;
}
int16_t Ball::getH(){
    return h;
}

const uint16_t* Ball::getImage(){
    return image;
}